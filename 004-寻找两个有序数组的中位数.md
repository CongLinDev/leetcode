# 寻找两个有序数组的中位数

## 题目描述

给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 `nums1` 和 `nums2` 不会同时为空。

>nums1 = [1, 3]  nums2 = [2]，则中位数是 2.0
>nums1 = [1, 2]  nums2 = [3, 4]，则中位数是 (2 + 3)/2 = 2.5

## 分析

该题可以使用递归法进行求解。

中位数的作用是**将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素**。

首先，让我们在任一位置 i 将 A 划分成两个部分：

```

          left_A             |        right_A
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]

```
由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（i = 0--m）。且`len(left_A)` = i, `len(right_A)` = m − i。

同理集合B也可以这样划分。

```
          left_B             |        right_B
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

现在合并 `left_A` 和 `left_B` 记为 `left_part` ；合并  `right_A` 和  `right_B` 记为 `right_part` 。

```
          left_part          |        right_part
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

若表达式 *len(left_part)==len(right_part)* 和 *max(left_part)<=min(right_part)* 成立，那么中位数 **median** = *(max(left_part) + min(right_part)) / 2*。

欲使上面两条件成立，只需要保证

1. i+j = m-i + n-j (或 m-i + n-j + 1) 如果 n >= m， 只需要使 i 处于0至m中， j = (m+n+1)/2 - i 
2. B[j-1] <= A[i] 以及 A[i-1] <= B[j] (为了简化分析，我假设A[i−1],B[j−1],A[i],B[j] 总是存在，哪怕出现 i=0，i=m，j=0，或是 j=n 这样的临界条件。将在最后讨论如何处理这些临界值)

所以我们只需要做的是 **在 [0，m] 中搜索并找到目标对象i，以使：B[j−1]<=A[i] 且 A[i-1]<=B[j],其中 j = (m+n+1)/2 - i**

可以按照以下步骤来进行二叉树搜索：
1. 设imin = 0， imax = m ，然后在[imin, imax]中进行搜索。
2. 令i=(imin+imax)/2，j = (m+n+1)/2 - i
3. 现在有len(left_part)==len(right_part)。我们只会遇到以下三种情况：
    *. B[j-1] <= A[i] 且 A[i-1] <= B[j]，即可以停止搜索。
    *. B[j-1] > A[i]，这意味着A[i]太小，必须增大i以使B[j-1] <= A[i]。将搜索范围调整为[i+1, imax]，并转到步骤2。
    *. A[i-1] > B[j]，这意味着A[i-1]太大，必须减小i以使 A[i-1] <= B[j]。将搜索范围调整为[imin, i-1]，并转到步骤2。

当找到目标对象 i 时，中位数为：max(A[i−1],B[j−1])（m+n 为奇数）;(max(A[i−1],B[j−1]) + min(A[i],B[j]))/2（m+n 为偶数）

现在考虑临界值i=0,i=m,j=0,j=n。

我们需要做的是确保max(left_part)≤min(right_part)。因此，如果 i 和 j 不是临界值（这意味着 A[i−1],B[j−1],A[i],B[j] 全部存在）, 那么必须同时检查 B[j−1]<=A[i] 以及A[i−1]≤B[j] 是否成立。 但是如果 A[i−1],B[j−1],A[i],B[j] 中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。 举个例子，如果i=0，那么 A[i−1] 不存在，我们就不需要检查 A[i−1]≤B[j] 是否成立

## 算法

```java

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        if(m > n){//确保 m <= n
            int []tempArray = nums1; nums1 = nums2; nums2 = tempArray;
            int tempInt = m; m = n; n = tempInt;
        }

        int imin = 0, imax = m; halfLen = (m + n + 1) / 2;
        while(imin <= imax){
            int i = (imin + imax) / 2;
            int j = halfLen - i;
            if(i < imax &&  nums2[j-1] > nums1[i]){//i较小
                imin = i + 1;//增大imin
            } else if(i > imin && nums1[i-1] > nums2[j]){//i较大
                imax = i - 1;//减小imax
            }else{//i刚好
                int maxLeft = 0;
                if(i == 0) {maxLeft = nums2[j-1]; }
                else if(j == 0) {maxLeft = nums1[i-1];}
                else {maxLeft = Math.max(nums1[i-1], nums2[j-1]);}
                if((m+n) % 2 == 1){
                    return maxLeft;
                }

                int minRight = 0;
                if(i == m) {minRight = nums2[j];}
                else if(j == n) {minRight = nums1[i];}
                else {minRight = Math.min(nums1[i], nums2[j]);}
                return (maxLeft + minRight) / 2.0;
            }
        }

        return 0;
    }
}
```