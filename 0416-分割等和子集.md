# 分割等和子集

## 题目描述

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

* 每个数组中的元素不会超过 100
* 数组的大小不会超过 200

```
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].

输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
```

## 分析

先计算数组和是否为偶数，若不是直接返回 `false`， 反之将其转化为 0-1 背包问题。

先使用二维数组来表示 `dp[i][j]`：表示从数组的 `[0, i]` 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和等于 `j`。

根据我们学习的 0-1 背包问题的状态转移推导过程，新来一个数，例如是 `nums[i]`，根据这个数可能选择也可能不被选择：

* 如果不选择 `nums[i]`，在 `[0, i - 1]` 这个子区间内已经有一部分元素，使得它们的和为 `j` ，那么 `dp[i][j] = true`；
* 如果选择 `nums[i]`，在 `[0, i - 1]` 这个子区间内就得找到一部分元素，使得它们的和为 `j - nums[i]` ，我既然这样写出来了，你就应该知道，这里讨论的前提条件是 `nums[i] <= j`。

以上二者成立一条都行。于是得到状态转移方程是：`dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]], (nums[i] <= j)`。

现在换成一维数组即为 `dp[j] |= dp[j - nums[i]]`。

## 算法

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num : nums)
            sum += num;
        if((sum & 1) == 1) return false;
        sum >>= 1;

        // 0 - 1 背包
        boolean []dp = new boolean[sum + 1];
        dp[0] = true;
        for(int i = 0; i < nums.length; i++){
            for(int j = sum; j >= nums[i]; j--){
                dp[j] |= dp[j - nums[i]];
            }
        }

        return dp[sum];
    }
}
```
