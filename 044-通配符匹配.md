# 通配符匹配

## 题目描述

给定一个字符串 `(s)` 和一个字符模式 `(p)` ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

* '?' 可以匹配任何单个字符。
* '\*' 可以匹配任意字符串（包括空字符串）。

两个字符串**完全匹配**才算匹配成功。

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 \*。

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。

输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。

输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".

输入:
s = "acdcb"
p = "a*c?b"
输入: false
```

## 分析

使用动态规划的办法解决该问题。既然用到动态规划，最重要的是 **设置初值** 和 **找到递推式** 。

于是，我们开始分析初值怎么设；其实很简单，把这个匹配问题可以想象成一个矩阵value，纵轴代表含有通配符的匹配字符串p， 横轴代表要匹配的字符串s。假设现在p="a*b", s="abc" 如图：

![1.png](https://i.loli.net/2019/02/24/5c71f38eed72e.png)

对应空位就是截止到当前的 (i,j) 位置，两字符串是否匹配。匹配为 T（true），不匹配为 F（false），最后返回最右下角的值，就是当前两个字符串是否匹配的最终值。

现在我们要做的设置初值，所以我们大可多加一行和一列，来填充初值；s既然是要匹配的，我们都设为 F，表示当前还未开始匹配。而p的初值，我们发现如果 `'*'` 和 `a` 调换位置，星号可以匹配任意字符串，所以value[i][0]的值取决于该位置是否为 `'*'` 和上一个位置value[i-1][0]是否为T（其实就是上一个位置是否也是星号），所以我们设置value[0][0]为 T。所以形成下图：

![2.png](https://i.loli.net/2019/02/24/5c71f4588b978.png)

此时初值已经设置完毕，我们要找到递推式；经局部推算，我们发现递推式应该有两种，一种是当p的字符是 `'*'` ，另一种是p的字符不是 `'*'` 。

先看星号的情况：当要计算value[2][1]（即要匹配a\*和a时），我们发现是取决于value[1][1]（即a和a是否匹配），当要计算value[2][2] (即要匹配a\*和ab时)，是取决于value[2][1] (即a\*和a是否匹配)。抽象一下，星号和任意字符（0或多个）都匹配。所以字符串截止到星号匹配的情况，取决于当前位置向上和向左的情况（即可以为0个字符，也可以为多个字符）。所以此时递推式为

```java
value[i][j] = (value[i][j-1] || value[i-1][j] || value[i-1][j-1]);
```

再看非星号的情况：其值取决于该字符是否匹配成功以及在此字符之前的字符串是否匹配成功。所以此时递推式为

```java
value[i][j] = (s.charAt(j-1) == p.charAt(i-1)) && value[i-1][j-1];
```

同理，`?` 其值取决于在此字符之前的字符串是否匹配成功。所以此时递推式为

```java
value[i][j] = value[i-1][j-1];
```

## 算法

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean [][]value = new boolean[p.length()+1][s.length()+1];
        value[0][0] = true;//空字符串匹配空字符串
        
        for(int i = 1; i <= p.length(); i++){//外层对模式p进行循环
            if(p.charAt(i-1) == '*'){//若模式为*，则匹配后面的部分
                value[i][0] = value[i-1][0];//匹配空字符串
                for(int j = 1; j <= s.length(); j++){
                    //其值取决于以前的字符串是否匹配成功或在此字符之前的字符串是否匹配成功
                    value[i][j] = (value[i][j-1] || value[i-1][j] || value[i-1][j-1]);
                }
            }else if(p.charAt(i-1) == '?'){//若模式为*，则匹配后面的一个字符
                value[i][0] = false;//不匹配空字符串
                for(int j = 1;j <= s.length(); j++){
                    //其值取决于在此字符之前的字符串是否匹配成功
                    value[i][j] = value[i-1][j-1];
                }
            }else{//其他字符
                value[i][0] = false;//不匹配空字符串
                for(int j = 1;j <= s.length(); j++){
                    //其值取决于该字符是否匹配成功以及在此字符之前的字符串是否匹配成功
                    value[i][j] = (s.charAt(j-1) == p.charAt(i-1)) && value[i-1][j-1];
                }                
            }
        }
        return value[p.length()][s.length()];
    }
}
```